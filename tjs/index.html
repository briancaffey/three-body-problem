<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - geometry - text</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <link type="text/css" rel="stylesheet" href="main.css">
    </head>
    <body>

        <div id="info">
            <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - procedural 3D text<br/>
            type to enter new text, drag to spin the text
        </div>

        <!-- Import maps polyfill -->
        <!-- Remove this when import maps will be widely supported -->
        <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

        <script type="importmap">
            {
                "imports": {
                  "three": "https://unpkg.com/three@v0.149.0/build/three.module.js",
                  "three/addons/": "https://unpkg.com/three@v0.149.0/examples/jsm/"
                }
              }
        </script>

        <script type="module">

            import * as THREE from 'three';

            import { FontLoader } from 'three/addons/loaders/FontLoader.js';
            import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
            import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

            import Stats from 'three/addons/libs/stats.module.js';

            import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

            // THREE.Cache.enabled = true;

            let container;
            let stats;

            let camera, cameraTarget, scene, renderer;

            let group, textMesh1, textMesh2, textGeo, materials;

            // length and width of each character cube
            const cubeSize = 100
            let font = undefined;
            loadFont();

            const height = 20,
                size = 70,
                hover = 30,

                bevelThickness = 2,
                bevelSize = 1.5;

            const mirror = true;

            let targetRotation = 0;
            let targetRotationOnPointerDown = 0;

            let pointerX = 0;
            let pointerXOnPointerDown = 0;

            let windowHalfX = window.innerWidth / 2;

            stats = new Stats();
            document.body.appendChild( stats.dom );

            function interpolateColor(colorA, colorB, x) {
                let result = new THREE.Color();
                result.lerpColors(colorA, colorB, x);
                return result;
            }

            // RAYCASTER
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();


            async function loadCubesData() {
                try {
                    const response = await fetch('output.json');
                    const cubesData = await response.json();
                    console.log("finished loading cube data...")
                    return cubesData;
                } catch (error) {
                    console.error('Error loading cubesData:', error);
                }
            }

            async function init() {
                // loadFont();
                const cubesData = await loadCubesData();

                container = document.createElement( 'div' );
                document.body.appendChild( container );

                // CAMERA

                camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 100000 );
                camera.position.set( 0, 400, 700 );

                cameraTarget = new THREE.Vector3( 0, 150, 0 );

                // SCENE

                scene = new THREE.Scene();
                scene.background = new THREE.Color( 0x000000 );
                // scene.fog = new THREE.Fog( 0x000000, 250, 1400 );

                // LIGHTS
                const dirLight = new THREE.DirectionalLight( 0xffffff, 2 );
                dirLight.position.set( 40, 100, 20 ).normalize();
                dirLight.castShadow = true;
                scene.add( dirLight );

                // // ambient light
                const ambientLight = new THREE.AmbientLight( 0xff1100 ); // soft white light
                ambientLight.castShadow = true;
                scene.add( ambientLight );

                // // scene.add( new THREE.AmbientLight( 0xf0f0f0, 3 ) );
                // const light = new THREE.SpotLight( 0xffffff, 10 );
                // light.position.set( 10000, 10000, 1500 );
                // light.angle = Math.PI * 0.2;
                // light.decay = 0;
                // light.castShadow = true;
                // light.shadow.camera.near = 20;
                // light.shadow.camera.far = 200000;
                // light.shadow.bias = - 0.000222;
                // light.shadow.mapSize.width = 1024;
                // light.shadow.mapSize.height = 1024;
                // scene.add( light );

                materials = [
                    new THREE.MeshStandardMaterial( { color: 0xffafff, flatShading: true, emissive: 0xffaabb } ), // front
                    new THREE.MeshStandardMaterial( { color: 0xffafaf, emissive: 0xffaabb } ) // side
                ];

                // RENDERER

                renderer = new THREE.WebGLRenderer( { antialias: true } );
                renderer.setPixelRatio( window.devicePixelRatio );

                renderer.setSize( window.innerWidth, window.innerHeight );
                container.appendChild( renderer.domElement );

                // Controls
                const controls = new OrbitControls( camera, renderer.domElement );
                controls.screenSpacePanning = true;
                controls.enablePan = true;
                controls.minDistance = 50;
                controls.maxDistance = 100000;

                // rows
                const n = 100;

                // cols
                const m = 30;


                cubesData.slice(0,3000).forEach((cubeData, index) => {

                    const cubeHeight = cubeData.occurences || cubeData.height;
                    const cubeCharacter = cubeData.character;
                    const cubeOverallRank = cubeData["overall_rank"];

                    const colorA = new THREE.Color( "red" );
                    const colorB = new THREE.Color( "green" );
                    const colorC = new THREE.Color( "blue" );
                    const colorD = new THREE.Color( "purple" );
                    const color = interpolateColor(colorA, colorB, cubeOverallRank / 5000);
                    const textColor = interpolateColor(colorC, colorD, cubeOverallRank / 5000);
                    const textMaterial = new THREE.MeshPhongMaterial({ color: textColor, specular: 0x111111, emissive: 0x0e0e0e});
                    const cubeMaterial = new THREE.MeshPhongMaterial({ color: color, specular: 0x111111, emissive: 0x000000 });

                    const geometry = new THREE.BoxGeometry(cubeSize - 20, cubeHeight, cubeSize - 20);

                    const cube = new THREE.Mesh(geometry, cubeMaterial);
                    cube.castShadow = true; //default is false
                    cube.receiveShadow = false; //default

                    // column
                    const colPosition = ((index % m) * cubeSize) + 50;
                    const rowPosition = (Math.floor(index / m) * cubeSize) + 50;
                    cube.position.set(
                        colPosition,
                        cubeData.height/2,
                        rowPosition,
                    );

                    scene.add(cube);

                    const textGeometry = new TextGeometry(cubeData.character, {
                        font: font,
                        curveSegments: 30,
                        bevelThickness: 1,
                        bevelSize: 1,
                        bevelEnabled: true,
                        height: 15,
                        size: 50
                    });

                    const textMesh = new THREE.Mesh(textGeometry, textMaterial);

                    // TODO use the same positions with cube above
                    textMesh.position.set(
                        colPosition - cubeSize / 2,
                        cubeHeight + 20,
                        rowPosition,
                    );
                    textMesh.userData.character = cubeCharacter;
                    textMesh.castShadow = true;
                    textMesh.receiveShadow = false;

                    scene.add(textMesh);
                });

                const gui = new GUI();

                gui.open();

                window.addEventListener( 'resize', onWindowResize );

                animate();

            }

            function onWindowResize() {

                windowHalfX = window.innerWidth / 2;

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }


            async function loadFont() {

                const loader = new FontLoader();
                loader.load('tinghei_regular.typeface.json',
                    function ( response ) {
                        font = response;
                        console.log("finished loading font...");
                        // init();

                    } ,
                    function ( xhr ) {
                        console.log( (xhr.loaded / xhr.total * 100) + '% loaded' );
                    },
                    // onError callback
                    function ( err ) {
                        console.log( 'An error happened' );
                    }
                );
            }

            function animate() {
                requestAnimationFrame( animate );
                render();
            }

            function onPointerMove( event ) {

                // calculate pointer position in normalized device coordinates
                // (-1 to +1) for both components

                mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

            }

            function render() {

                renderer.clear();
                raycaster.setFromCamera( mouse, camera );
                const intersects = raycaster.intersectObjects( scene.children );
                for ( let i = 0; i < intersects.length; i ++ ) {
                    console.log("intersect");

                    // intersects[ i ].object.material.color.set( 0x000000 );
                    // console.log(intersects[i].object)

                }
                renderer.render( scene, camera );
                stats.update();

            }
            window.addEventListener( 'pointermove', onPointerMove );

            await init();

        </script>

    </body>
</html>